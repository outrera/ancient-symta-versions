(in-package :symta)


;; (cons metric (cons left right))
(defmacro m (o) `(the fixnum (car ,o)))
(defmacro l (o) `(the cons (cadr ,o)))
(defmacro r (o) `(the cons (cddr ,o)))

(defmacro node (a b)
  (let ((l (gensym))
        (r (gensym)))
    `(let ((,l ,a) (,r ,b))
       (cons (the fixnum (+ (m ,l) (m ,r))) (cons ,l ,r)))))

(defmacro pt? (o) `(consp ,o))

(defun pt-balance (n)
  (declare (optimize (safety 0) (speed 3) (debug 0) (space 0)
                     (compilation-speed 0))
           (cons n))
  (if (< (m n) 4) (return-from pt-balance n))
  (let ((ml (m (l n)))
        (mr (m (r n))))
    (cond ((> mr (the fixnum (* 2 ml)))
           (let ((ln (l n))
                 (rn (pt-balance (r n))))
             (node (pt-balance (node ln (l rn)))
                   (r rn))))
          ((> ml (the fixnum (* 2 mr)))
           (let ((ln (pt-balance (l n)))
                 (rn (r n)))
             (node (l ln)
                   (pt-balance (node (r ln) rn)))))
          (t n))))

(defun pt-cat (a b)
  (declare (optimize (safety 0) (speed 3) (debug 0) (space 0)
                     (compilation-speed 0)))
  (unless a (return-from pt-cat b))
  (unless b (return-from pt-cat a))
  (pt-balance (node a b)))

(defun pt-cut (n i)
  (declare (optimize (safety 0) (speed 3) (debug 0) (space 0)
                     (compilation-speed 0))
           (cons n) (fixnum i))
  (cond
    ((= i 0) (cons nil n))
    ((< i (m n))
     (let ((l (l n))
           (r (r n)))
       (if (< i (m l))
           (let ((x (pt-cut l i)))
             (cons (car x)
                   (pt-cat (cdr x) r)))
           (let ((x (pt-cut r (the fixnum (- i (m l))))))
             (cons (pt-cat l (car x))
                   (cdr x))))))
    (t (cons n nil))))

(defun dup (n e)
  (labels ((dup-rec (n e)
             (if (= n 0)
                 nil
                 (let ((m (truncate (log n 2))))
                   (pt-cat (dup-rec (- n (truncate (expt 2 m))) e)
                           (loop as i below m and j = e then (pt-cat j j)
                              finally (return j)))))))
    (if (/= n 0) (dup-rec n (cons 1 e)))))

(defun pt-ind (n i)
  (declare (optimize (safety 0) (speed 3) (debug 0) (space 0)
                     (compilation-speed 0))
           (cons n) (fixnum i))
  (if (= (m n) 1) (return-from pt-ind (cdr n)))
  (let* ((ln (l n))
         (ml (m ln)))
    (if (< i ml)
        (pt-ind ln i)
        (pt-ind (r n) (- i ml)))))

(defun pt-cng (n i v)
  (declare (optimize (safety 0) (speed 3) (debug 0) (space 0)
                     (compilation-speed 0))
           (cons n) (fixnum i))
  (if (= (m n) 1) (return-from pt-cng (cons 1 v)))
  (let* ((ln (l n))
         (ml (m ln)))
    (cons (m n)
          (if (< i ml)
              (cons (pt-cng ln i v) (r n))
              (cons (l n) (pt-cng (r n) (- i ml) v))))))

(defun pt-map (f s)
  (declare (optimize (safety 0) (speed 3) (debug 0) (space 0)
                     (compilation-speed 0))
           (cons s) (function f))
  (let ((n (m s)))
    (if (= n 1)
        (cons 1 (funcall f (cdr s)))
        (cons n (cons (pt-map f (l s))
                      (pt-map f (r s)))))))

(defun pt-fe (f s) ; for each
  (declare (optimize (safety 0) (speed 3) (debug 0) (space 0)
                     (compilation-speed 0))
           (cons s) (function f))
  (let ((n (m s)))
    (if (= n 1)
        (funcall f (cdr s))
        (progn (pt-map f (l s))
               (pt-map f (r s))))))

(defun pt-fold (i f s)
  (labels ((pt-fold-rec (f x s)
             (declare (optimize (safety 0) (speed 3) (debug 0) (space 0)
                                (compilation-speed 0))
                      (cons s) (function f))
             (if (= (m s) 1)
                 (funcall f x (cdr s))
                 (pt-fold-rec f   (pt-fold-rec f x (l s))   (r s)))))
    (pt-fold-rec f i s)))

(defun pt-to-list (s)
  (labels ((pt-to-list-rec (n r)
             (if (= (m n) 1)
                 (cons (cdr n) r)
                 (pt-to-list-rec (l n) (pt-to-list-rec (r n) r)))))
    (pt-to-list-rec s nil)))


;; listifies node's internal structures recursively
;; use for debugging
(defun ln (n)
  (if (= (m n) 1)
      (list (car n) (cdr n))
      (list (m n) (ln (l n)) (ln (r n)))))
